"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const lodash_merge_1 = __importDefault(require("lodash.merge"));
const const_1 = require("../../const");
const globals_1 = require("../../globals");
const Comms_1 = __importDefault(require("../../helpers/Comms"));
const utils_1 = require("../../helpers/utils");
const homeAssistant_1 = require("../../homeAssistant");
const nodeDefaults = {
    name: {},
    version: (nodeDef) => nodeDef.version || 0,
    addon: {},
    rejectUnauthorizedCerts: {},
    ha_boolean: {},
    connectionDelay: {},
    cacheJson: {},
    heartbeat: {},
    heartbeatInterval: {},
    areaSelector: {},
    deviceSelector: {},
    entitySelector: {},
};
class ConfigServer {
    constructor({ node, config, }) {
        this.events = {};
        this.exposedNodes = {};
        this.isHomeAssistantRunning = false;
        this.onHaEventsOpen = () => {
            this.setOnContext('isConnected', true);
            this.node.log(`Connected to ${this.hostname}`);
        };
        this.onHaStateChanged = (changedEntity) => {
            const states = this.getFromContext('states');
            if (states) {
                states[changedEntity.entity_id] = changedEntity.event
                    .new_state;
                this.setOnContext('states', states);
            }
        };
        this.onHaStatesLoaded = (states) => {
            this.setOnContext('states', states);
            this.node.debug('States Loaded');
        };
        this.onHaServicesLoaded = () => {
            this.node.debug('Services Loaded');
        };
        this.onHaServicesUpdated = (services) => {
            this.setOnContext('services', services);
        };
        this.onHaEventsConnecting = () => {
            this.setOnContext('isConnected', false);
            this.setOnContext('isRunning', false);
            this.node.log(`Connecting to ${this.hostname}`);
        };
        this.onHaEventsClose = () => {
            if (this.getFromContext('isConnected')) {
                this.node.log(`Connection closed to ${this.hostname}`);
            }
            this.setOnContext('isConnected', false);
            this.setOnContext('isRunning', false);
        };
        this.onHaEventsRunning = () => {
            this.setOnContext('isRunning', true);
            this.node.debug(`HA State: running`);
        };
        this.onHaEventsError = (err) => {
            this.setOnContext('isConnected', false);
            this.setOnContext('isRunning', false);
            this.node.debug(err);
        };
        this.onIntegrationEvent = (eventType) => {
            if (eventType === const_1.INTEGRATION_NOT_LOADED &&
                !this.isHomeAssistantRunning) {
                return;
            }
            this.node.debug(`Integration: ${eventType}`);
        };
        this.registerEvents = () => {
            var _a;
            (_a = this === null || this === void 0 ? void 0 : this.homeAssistant) === null || _a === void 0 ? void 0 : _a.subscribeEvents();
        };
        this.node = node;
        this.config = (0, lodash_merge_1.default)({}, nodeDefaults, config);
        this.setOnContext('states', {});
        this.setOnContext('services', {});
        this.setOnContext('isConnected', false);
        node.on('close', this.onClose.bind(this));
    }
    get hostname() {
        return this.config.addon ? homeAssistant_1.SUPERVISOR_URL : this.node.credentials.host;
    }
    async init() {
        try {
            this.homeAssistant = (0, homeAssistant_1.createHomeAssistantClient)(this.config, this.node.credentials);
            this.startListeners();
            this.comms = new Comms_1.default(this.homeAssistant, this.node.id);
            await this.homeAssistant.websocket.connect();
        }
        catch (e) {
            if (e instanceof Error) {
                this.node.error(globals_1.RED._(e.message, { base_url: this.hostname }));
            }
            else {
                this.node.error(e);
            }
        }
    }
    startListeners() {
        var _a, _b;
        // Setup event listeners
        this.events = {
            'ha_client:close': this.onHaEventsClose,
            'ha_client:open': this.onHaEventsOpen,
            'ha_client:connecting': this.onHaEventsConnecting,
            'ha_client:error': this.onHaEventsError,
            'ha_client:running': this.onHaEventsRunning,
            'ha_client:states_loaded': this.onHaStatesLoaded,
            'ha_client:services_loaded': this.onHaServicesLoaded,
            [const_1.HA_EVENT_SERVICES_UPDATED]: this.onHaServicesUpdated,
            'ha_events:state_changed': this.onHaStateChanged,
            integration: this.onIntegrationEvent,
        };
        (0, utils_1.addEventListeners)(this.events, (_a = this === null || this === void 0 ? void 0 : this.homeAssistant) === null || _a === void 0 ? void 0 : _a.eventBus);
        (_b = this === null || this === void 0 ? void 0 : this.homeAssistant) === null || _b === void 0 ? void 0 : _b.addListener('ha_client:connected', this.registerEvents, { once: true });
    }
    get nameAsCamelcase() {
        return (0, utils_1.toCamelCase)(this.config.name);
    }
    setOnContext(key, value) {
        var _a, _b;
        var _c;
        const haCtx = (_a = this.node.context().global.get('homeassistant')) !== null && _a !== void 0 ? _a : {};
        (_b = haCtx[_c = this.nameAsCamelcase]) !== null && _b !== void 0 ? _b : (haCtx[_c] = {
            states: {},
            services: {},
            isConnected: false,
            isRunning: false,
        });
        haCtx[this.nameAsCamelcase][key] = value;
        this.node.context().global.set('homeassistant', haCtx);
    }
    getFromContext(key) {
        var _a;
        const haCtx = this.node
            .context()
            .global.get('homeassistant');
        return (_a = haCtx === null || haCtx === void 0 ? void 0 : haCtx[this.nameAsCamelcase]) === null || _a === void 0 ? void 0 : _a[key];
    }
    // Close WebSocket client on redeploy or node-RED shutdown
    onClose(removed, done) {
        if (this.homeAssistant) {
            // Remove event listeners
            (0, utils_1.removeEventListeners)(this.events, this.homeAssistant.eventBus);
            this.node.log(`Closing connection to ${this.hostname}`);
            this.homeAssistant.close();
        }
        done();
    }
}
exports.default = ConfigServer;
