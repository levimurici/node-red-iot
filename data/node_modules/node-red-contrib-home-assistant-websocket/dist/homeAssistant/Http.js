"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const axios_1 = __importDefault(require("axios"));
const debug_1 = __importDefault(require("debug"));
const https_1 = __importDefault(require("https"));
const utils_1 = require("../helpers/utils");
const debug = (0, debug_1.default)('home-assistant:http');
class Http {
    constructor(config) {
        const apiOpts = {
            baseURL: `${config.host}/api`,
            headers: { Authorization: `Bearer ${config.access_token}` },
        };
        if (!config.rejectUnauthorizedCerts) {
            apiOpts.httpsAgent = new https_1.default.Agent({
                rejectUnauthorized: false,
            });
        }
        this.client = axios_1.default.create(apiOpts);
    }
    async getHistory(timestamp, filterEntityId, endTimestamp, { include, exclude, flatten, } = {}) {
        let path = 'history/period';
        if (timestamp) {
            path = `${path}/${timestamp}`;
        }
        // eslint-disable-next-line camelcase
        const params = {};
        if (filterEntityId) {
            params.filter_entity_id = filterEntityId;
        }
        if (endTimestamp) {
            params.end_time = endTimestamp;
        }
        // History returns an array for each entity_id and that array contains objects for each history item
        const results = await this.get(path, params);
        // Filter out results by regex, include/exclude should already be an instance of RegEx
        if (include || exclude) {
            return results.reduce((acc, entityArr) => {
                var _a, _b;
                const entityId = (_b = (_a = entityArr[0]) === null || _a === void 0 ? void 0 : _a.entity_id) !== null && _b !== void 0 ? _b : null;
                if (entityId && (0, utils_1.shouldInclude)(entityId, include, exclude)) {
                    acc.push(entityArr);
                }
                return acc;
            }, []);
        }
        // Instead of returning the data from home assistant ( array for each entity_id ) return one flattened array
        // of one item per history entry
        if (flatten) {
            return results
                .reduce((acc, entityArr) => {
                return [...acc, ...entityArr];
            }, [])
                .sort((a, b) => {
                if (a.last_updated < b.last_updated) {
                    return -1;
                }
                if (a.last_updated > b.last_updated) {
                    return 1;
                }
                return 0;
            });
        }
        return results;
    }
    fireEvent(event, data) {
        return this.post(`events/${event}`, data);
    }
    renderTemplate(templateString) {
        return this.post('template', { template: templateString }, 'text');
    }
    async post(path, data = {}, responseType = 'json') {
        var _a;
        debug(`HTTP POST: ${this.client.defaults.baseURL}/${path}`);
        this.client.defaults.responseType = responseType;
        const response = await this.client.post(path, data).catch((err) => {
            debug(`POST: request error: ${err.toString()}`);
            throw err;
        });
        return responseType === 'json'
            ? (_a = response.data) !== null && _a !== void 0 ? _a : ''
            : response.data;
    }
    async get(path, params = {}, responseType = 'json') {
        var _a;
        debug(`HTTP GET: ${this.client.defaults.baseURL}/${path}`);
        this.client.defaults.responseType = responseType;
        const response = await this.client
            .request({ url: path, params: params })
            .catch((err) => {
            debug(`GET: request error: ${err.toString()}`);
            throw err;
        });
        return responseType === 'json'
            ? (_a = response.data) !== null && _a !== void 0 ? _a : ''
            : response.data;
    }
}
exports.default = Http;
