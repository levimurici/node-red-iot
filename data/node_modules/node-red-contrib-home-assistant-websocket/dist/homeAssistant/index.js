"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createHomeAssistantClient = exports.SUPERVISOR_URL = void 0;
const events_1 = require("events");
const url_1 = require("url");
const HomeAssistant_1 = __importDefault(require("./HomeAssistant"));
const Http_1 = __importDefault(require("./Http"));
const Websocket_1 = __importDefault(require("./Websocket"));
exports.SUPERVISOR_URL = 'http://supervisor/core';
function createHomeAssistantClient(config, credentials) {
    const eventBus = new events_1.EventEmitter();
    eventBus.setMaxListeners(0);
    const creds = createCredentials(credentials, config);
    const httpConfig = createHttpConfig(creds, config);
    const websocketConfig = createWebsocketConfig(creds, config);
    const httpAPI = new Http_1.default(httpConfig);
    const websocketAPI = new Websocket_1.default(websocketConfig, eventBus);
    return new HomeAssistant_1.default({ websocketAPI, httpAPI, eventBus });
}
exports.createHomeAssistantClient = createHomeAssistantClient;
function createCredentials(credentials, config) {
    let host;
    // eslint-disable-next-line camelcase
    let access_token = credentials.access_token;
    // Check if using HA Add-on and import proxy token
    const addonBaseUrls = ['http://hassio/homeassistant', exports.SUPERVISOR_URL];
    if (config.addon || addonBaseUrls.includes(credentials.host)) {
        if (!process.env.SUPERVISOR_TOKEN) {
            throw new Error('Supervisor token not found.');
        }
        host = exports.SUPERVISOR_URL;
        // eslint-disable-next-line camelcase
        access_token = process.env.SUPERVISOR_TOKEN;
    }
    else {
        host = getBaseUrl(credentials.host);
    }
    return {
        host,
        // eslint-disable-next-line camelcase
        access_token,
    };
}
function createHttpConfig(credentials, config) {
    return {
        access_token: credentials.access_token,
        host: credentials.host,
        rejectUnauthorizedCerts: config.rejectUnauthorizedCerts,
    };
}
function createWebsocketConfig(credentials, config = {
    rejectUnauthorizedCerts: true,
    connectionDelay: true,
}) {
    var _a, _b, _c;
    const connectionDelay = credentials.host !== exports.SUPERVISOR_URL
        ? false
        : (_a = config.connectionDelay) !== null && _a !== void 0 ? _a : false;
    const heartbeatInterval = (_b = Number(config.heartbeatInterval)) !== null && _b !== void 0 ? _b : 0;
    const heartbeat = config.heartbeat && Number.isInteger(heartbeatInterval)
        ? heartbeatInterval
        : 0;
    return {
        access_token: credentials.access_token,
        host: credentials.host,
        rejectUnauthorizedCerts: (_c = config.rejectUnauthorizedCerts) !== null && _c !== void 0 ? _c : true,
        connectionDelay,
        heartbeatInterval: heartbeat,
    };
}
function getBaseUrl(url) {
    const errorMessage = validateBaseUrl(url);
    if (errorMessage) {
        throw new Error(errorMessage);
    }
    return url.trim();
}
function validateBaseUrl(baseUrl) {
    if (!baseUrl) {
        return 'config-server.errors.empty_base_url';
    }
    let parsedUrl;
    try {
        parsedUrl = new url_1.URL(baseUrl);
    }
    catch (e) {
        return 'config-server.errors.invalid_base_url';
    }
    if (parsedUrl.protocol !== 'http:' && parsedUrl.protocol !== 'https:') {
        return 'config-server.errors.invalid_protocol';
    }
}
